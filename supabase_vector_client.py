import os
import json
import logging
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional, Tuple
from dotenv import load_dotenv

from openai import OpenAI
from supabase import create_client, Client
import requests

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ActivityWatchSupabaseClient:
    def __init__(self):
        # Initialize Supabase client with service role key for unrestricted access
        self.supabase_url = os.getenv('SUPABASE_URL')
        self.supabase_key = os.getenv('SUPABASE_SERVICE_ROLE_KEY')  # Use service role key directly
        print("DEBUG: SUPABASE_SERVICE_ROLE_KEY =", self.supabase_key)  # Debug print
        self.supabase: Client = create_client(self.supabase_url, self.supabase_key)
        
        # Initialize OpenAI client for embeddings
        self.openai_client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
        
        # ActivityWatch configuration
        self.aw_server_url = os.getenv('AW_SERVER_URL', 'http://localhost:5600')
        
        logger.info("ActivityWatch Supabase Client initialized with service role key")
    
    def generate_embedding(self, text: str) -> List[float]:
        """Generate embedding for text using OpenAI"""
        if not text or not text.strip():
            return [0.0] * 1536  # Return zero vector for empty text
        
        try:
            response = self.openai_client.embeddings.create(
                input=text,
                model="text-embedding-ada-002"
            )
            return response.data[0].embedding
        except Exception as e:
            logger.error(f"Error generating embedding: {e}")
            return [0.0] * 1536
    
    def create_bucket(self, bucket_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create a new bucket in Supabase"""
        try:
            bucket_record = {
                'id': bucket_data['id'],
                'name': bucket_data.get('name'),
                'type': bucket_data['type'],
                'client': bucket_data['client'],
                'hostname': bucket_data['hostname'],
                'created': bucket_data['created'],
                'data': bucket_data.get('data', {})
            }
            
            result = self.supabase.table('buckets').insert(bucket_record).execute()
            logger.info(f"Created bucket: {bucket_data['id']}")
            return result.data[0] if result.data else {}
            
        except Exception as e:
            logger.error(f"Error creating bucket: {e}")
            raise
    
    def insert_event(self, bucket_id: str, event_data: Dict[str, Any]) -> Dict[str, Any]:
        """Insert an event with vector embeddings"""
        try:
            # Extract text for embeddings
            title = event_data['data'].get('title', '')
            app_name = event_data['data'].get('app', '')
            
            # Generate separate embeddings for app names and window titles
            app_embedding = self.generate_embedding(app_name)
            title_embedding = self.generate_embedding(title)
            
            # Prepare event record (event_type is now generated by database)
            event_record = {
                'bucket_id': bucket_id,
                'timestamp': event_data['timestamp'],
                'duration': float(event_data['duration']),
                'data': event_data['data'],
                'app_embedding': app_embedding,
                'title_embedding': title_embedding
            }
            
            result = self.supabase.table('events').insert(event_record).execute()
            logger.info(f"Inserted event {result.data[0]['id'] if result.data else 'unknown'}")
            return result.data[0] if result.data else {}
            
        except Exception as e:
            logger.error(f"Error inserting event: {e}")
            raise
    
    def semantic_search(self, query: str, bucket_id: Optional[str] = None, 
                       limit: int = None, similarity_threshold: float = 0.7) -> List[Dict[str, Any]]:
        """Perform semantic search on events using pgvector cosine similarity"""
        try:
            logger.info(f"Starting semantic search for query: '{query}' with threshold: {similarity_threshold}")
            # Generate embedding for the query
            query_embedding = self.generate_embedding(query)
            logger.info(f"Generated embedding of length: {len(query_embedding)}")
            
            # Try the pgvector function first
            try:
                # Use a very high limit or no limit for comprehensive search
                search_limit = limit if limit else 10000  # Very high limit to get all results
                logger.info(f"Calling RPC with limit: {search_limit}")
                
                result = self.supabase.rpc(
                    'match_events_by_embedding',
                    {
                        'query_embedding': query_embedding,
                        'match_threshold': float(similarity_threshold),  # Ensure it's a float
                        'match_count': int(search_limit)  # Use high limit
                    }
                ).execute()
                
                # Debug: log any errors
                if getattr(result, 'error', None):
                    logger.error(f"RPC match_events_by_embedding error: {result.error}")
                else:
                    logger.info(f"RPC returned {len(result.data) if result.data else 0} rows")
                    if result.data:
                        logger.info(f"Sample result app: {result.data[0].get('data', {}).get('app', 'Unknown')}")
                
                # Filter by bucket if specified
                events = result.data if result.data else []
                logger.info(f"After bucket filter: {len(events)} events")
                if bucket_id:
                    events = [event for event in events if event.get('bucket_id') == bucket_id]
                
                # Filter by similarity threshold and relevance
                filtered_events = []
                for event in events:
                    similarity = event.get('similarity', 1.0)
                    # Ensure similarity is a number
                    try:
                        similarity = float(similarity)
                        # Lower distance more similar
                        if similarity <= similarity_threshold:
                            logger.info(f"Event passed threshold: {similarity} <= {similarity_threshold}")
                            # Additional relevance check for specific apps
                            app = event.get('data', {}).get('app', '')
                            title = event.get('data', {}).get('title', '')
                            query_lower = query.lower()
                            
                            # For specific app searches, ensure the app name matches
                            if query_lower in ['whatsapp', 'signal', 'netflix', 'spotify', 'youtube', 'cursor', 'chrome']:
                                if query_lower in app:
                                    filtered_events.append(event)
                                    logger.info(f"Added specific app match: {app}")
                            else:
                                # For general searches, include all relevant results
                                filtered_events.append(event)
                                logger.info(f"Added general match: {app}")
                    except (ValueError, TypeError):
                        logger.warning(f"Invalid similarity value: {similarity}")
                        continue
                
                logger.info(f"Final filtered events: {len(filtered_events)}")
                # Sort by timestamp (latest first) and return
                filtered_events.sort(key=lambda x: x.get('event_timestamp', x.get('timestamp', '')), reverse=True)
                logger.info(f"Vector search found {len(filtered_events)} results")
                return filtered_events
                
            except Exception as func_error:
                logger.warning(f"Vector function failed, trying direct query: {func_error}")
                
                # Fallback: direct query approach with better error handling
                try:
                    # Get ALL events with embeddings (no limit)
                    result = self.supabase.table('events').select('*').not_.is_('app_embedding', 'null').execute()
                    events = result.data if result.data else []
                    
                    logger.info(f"Fallback vector search: Found {len(events)} events with embeddings")
                    
                    # Filter by bucket if specified
                    if bucket_id:
                        events = [event for event in events if event.get('bucket_id') == bucket_id]
                    
                    # Compute similarities and sort
                    event_similarities = []
                    for event in events:
                        app_embedding = event.get('app_embedding')
                        title_embedding = event.get('title_embedding')
                        
                        # Calculate best similarity from app or title
                        best_similarity = 0.0
                        if app_embedding and isinstance(app_embedding, list):
                            try:
                                app_similarity = self._cosine_similarity(query_embedding, app_embedding)
                                best_similarity = max(best_similarity, app_similarity)
                            except Exception as e:
                                logger.warning(f"Error calculating app similarity: {e}")
                                continue
                        
                        if title_embedding and isinstance(title_embedding, list):
                            try:
                                title_similarity = self._cosine_similarity(query_embedding, title_embedding)
                                best_similarity = max(best_similarity, title_similarity)
                            except Exception as e:
                                logger.warning(f"Error calculating title similarity: {e}")
                                continue
                        
                        # Ensure best_similarity is a valid float
                        try:
                            best_similarity = float(best_similarity)
                            if not (0.0 <= best_similarity <= 1.0):
                                best_similarity = 0.0
                        except (ValueError, TypeError):
                            logger.warning(f"Invalid similarity value: {best_similarity}")
                            best_similarity = 0.0
                        
                        if best_similarity >= similarity_threshold:
                            # Additional relevance check for specific apps
                            app = event.get('data', {}).get('app', '').lower()
                            query_lower = query.lower()
                            
                            # For specific app searches, ensure the app name matches
                            if query_lower in ['whatsapp', 'signal', 'netflix', 'spotify', 'youtube', 'cursor', 'chrome']:
                                if query_lower in app:
                                    event_similarities.append((event, best_similarity))
                            else:
                                # For general searches, include all relevant results
                                event_similarities.append((event, best_similarity))
                    
                    # Sort by similarity and return ALL results (no limit)
                    event_similarities.sort(key=lambda x: x[1], reverse=True)
                    results = [event for event, _ in event_similarities]  # No limit here
                    
                    # Sort by timestamp (latest first) and return
                    results.sort(key=lambda x: x.get('event_timestamp', x.get('timestamp', '')), reverse=True)
                    logger.info(f"Fallback vector search found {len(results)} results")
                    return results
                    
                except Exception as fallback_error:
                    logger.error(f"Fallback vector search also failed: {fallback_error}")
                    return []
            
        except Exception as e:
            logger.error(f"Error in semantic search: {e}")
            return []
    
    def _cosine_similarity(self, vec1: List[float], vec2: List[float]) -> float:
        """Compute cosine similarity between two vectors"""
        try:
            import numpy as np
            vec1_np = np.array(vec1)
            vec2_np = np.array(vec2)
            return np.dot(vec1_np, vec2_np) / (np.linalg.norm(vec1_np) * np.linalg.norm(vec2_np))
        except ImportError:
            # Fallback without numpy
            dot_product = sum(a * b for a, b in zip(vec1, vec2))
            norm1 = sum(a * a for a in vec1) ** 0.5
            norm2 = sum(b * b for b in vec2) ** 0.5
            return dot_product / (norm1 * norm2) if norm1 * norm2 > 0 else 0.0
    
    def get_events_by_time_range(self, bucket_id: str, start_time: datetime, 
                                end_time: datetime, limit: int = 100) -> List[Dict[str, Any]]:
        """Get events within a time range"""
        try:
            result = self.supabase.table('events')\
                .select('*')\
                .eq('bucket_id', bucket_id)\
                .gte('timestamp', start_time.isoformat())\
                .lte('timestamp', end_time.isoformat())\
                .order('timestamp', desc=True)\
                .limit(limit)\
                .execute()
            
            return result.data if result.data else []
            
        except Exception as e:
            logger.error(f"Error getting events by time range: {e}")
            return []
    
    def get_buckets(self) -> List[Dict[str, Any]]:
        """Get all buckets"""
        try:
            result = self.supabase.table('buckets').select('*').execute()
            return result.data if result.data else []
        except Exception as e:
            logger.error(f"Error getting buckets: {e}")
            return []
    
    def get_events_count(self, bucket_id: str) -> int:
        """Get count of events in a bucket"""
        try:
            result = self.supabase.table('events').select('id', count='exact').eq('bucket_id', bucket_id).execute()
            return result.count if result.count else 0
        except Exception as e:
            logger.error(f"Error getting events count: {e}")
            return 0
    
    def simple_text_search(self, query: str, bucket_id: Optional[str] = None, 
                          limit: int = None) -> List[Dict[str, Any]]:
        """Simple text-based search as fallback when vector search fails"""
        try:
            # Get ALL events (no limit for comprehensive search)
            result = self.supabase.table('events').select('*').execute()
            events = result.data if result.data else []
            
            logger.info(f"Text search: Found {len(events)} total events in database")
            
            # Filter by bucket if specified
            if bucket_id:
                events = [event for event in events if event.get('bucket_id') == bucket_id]
                logger.info(f"Text search: Filtered to {len(events)} events in bucket {bucket_id}")
            
            # Simple text matching with exact matching for specific apps
            query_lower = query.lower()
            matching_events = []
            
            # Define exact app matches for specific queries
            exact_app_matches = {
                'whatsapp': ['whatsapp', 'whatsapp desktop', 'whatsapp web'],
                'signal': ['signal', 'signal desktop'],
                'netflix': ['netflix', 'netflix app'],
                'spotify': ['spotify', 'spotify app'],
                'youtube': ['youtube', 'youtube app'],
                'cursor': ['cursor', 'cursor editor'],
                'chrome': ['chrome', 'google chrome', 'brave browser'],
                'browser': ['chrome', 'google chrome', 'brave browser', 'safari', 'firefox']
            }
            
            for event in events:
                data = event.get('data', {})
                app = data.get('app', '').lower()
                title = data.get('title', '').lower()
                
                # Check for exact app matches first
                if query_lower in exact_app_matches:
                    target_apps = exact_app_matches[query_lower]
                    if any(target_app in app for target_app in target_apps):
                        matching_events.append(event)
                        continue
                
                # Check direct match in app name (most important)
                if query_lower in app:
                    matching_events.append(event)
                    continue
                
                # Check direct match in title (less important)
                if query_lower in title:
                    matching_events.append(event)
                    continue
                
                # Check synonyms only for general terms
                synonyms = {
                    'code': ['cursor', 'vscode', 'visual studio code'],
                    'editor': ['cursor', 'vscode', 'visual studio code'],
                    'social': ['facebook', 'instagram', 'twitter', 'whatsapp', 'signal'],
                    'communication': ['whatsapp', 'signal', 'telegram', 'discord']
                }
                
                for synonym_key, synonym_list in synonyms.items():
                    if query_lower in synonym_key or synonym_key in query_lower:
                        for synonym in synonym_list:
                            if synonym in app or synonym in title:
                                matching_events.append(event)
                                break
                        if event in matching_events:
                            break
            
            # Sort by timestamp (most recent first)
            matching_events.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
            
            logger.info(f"Text search: Found {len(matching_events)} matching events for '{query}'")
            
            # Debug: Show what apps were actually found
            apps_found = set()
            for event in matching_events[:5]:
                app = event.get('data', {}).get('app', 'Unknown')
                apps_found.add(app)
            logger.info(f"Text search: Apps found: {list(apps_found)}")
            
            # Return all matching events, no limit
            return matching_events
            
        except Exception as e:
            logger.error(f"Error in simple text search: {e}")
            return []
    
    def search_events(self, query: str, search_mode: str = "Vector (semantic)", 
                     limit: int = None, similarity_threshold: float = 0.7) -> Tuple[List[Dict[str, Any]], str]:
        """Search events using the specified search mode with improved filtering"""
        try:
            query_lower = query.lower()
            search_info = ""
            results = []
            
            # Define specific query types for better filtering
            specific_queries = {
                'cursor': ['cursor', 'code', 'editor', 'programming', 'development'],
                'whatsapp': ['whatsapp', 'message', 'chat'],
                'browser': ['browser', 'chrome', 'firefox', 'safari', 'web'],
                'terminal': ['terminal', 'command', 'cli'],
                'file': ['file', 'document', 'folder'],
                'work': ['work', 'meeting', 'project'],
                'social': ['social', 'facebook', 'instagram', 'twitter'],
                'entertainment': ['netflix', 'youtube', 'spotify', 'music', 'video']
            }
            
            # Determine query type
            query_type = None
            for key, keywords in specific_queries.items():
                if any(keyword in query_lower for keyword in keywords):
                    query_type = key
                    break
            
            if search_mode == "Vector (semantic)":
                results = self.search_events_vector(query, limit=limit, similarity_threshold=similarity_threshold)
                search_info = "Using vector semantic search"
                
            elif search_mode == "Text (exact)":
                results = self.simple_text_search(query, limit=limit)
                search_info = "Using exact text matching"
                
            else:  # Hybrid search
                vector_results = self.search_events_vector(query, limit=limit, similarity_threshold=similarity_threshold)
                text_results = self.simple_text_search(query, limit=limit)
                
                # Combine results, removing duplicates
                seen_ids = set()
                results = []
                for event in vector_results + text_results:
                    event_id = event.get('id')
                    if event_id not in seen_ids:
                        results.append(event)
                        seen_ids.add(event_id)
                
                search_info = "Using hybrid search (vector + text)"
            
            # Apply specific filtering based on query type
            if query_type:
                filtered_results = []
                for event in results:
                    data = event.get('data', {})
                    app = data.get('app', '').lower()
                    title = data.get('title', '').lower()
                    
                    # Apply specific filtering rules
                    if query_type == 'cursor' and 'cursor' not in app:
                        continue
                    elif query_type == 'whatsapp' and 'whatsapp' not in app:
                        continue
                    elif query_type == 'browser' and not any(browser in app for browser in ['chrome', 'firefox', 'safari', 'brave']):
                        continue
                    elif query_type == 'terminal' and not any(term in app for term in ['terminal', 'iterm2', 'alacritty']):
                        continue
                    
                    filtered_results.append(event)
                
                results = filtered_results
                search_info += f" (filtered for {query_type})"
            
            # Sort results by timestamp
            results.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
            
            return results, search_info
            
        except Exception as e:
            logger.error(f"Error in search_events: {e}")
            return [], f"Search error: {str(e)}"
    
    def filter_cursor_results(self, events):
        """Filter results to only include Cursor-related events"""
        cursor_events = []
        for event in events:
            data = event.get('data', {})
            app = data.get('app', '').lower()
            title = data.get('title', '').lower()
            
            # Only include events where the app is Cursor
            if app == 'cursor':
                cursor_events.append(event)
            
        return cursor_events
    
    def search_events_vector(self, query, limit=None, similarity_threshold=0.7):
        """Search events using vector similarity with improved filtering"""
        try:
            query_lower = query.lower()
            
            # Define specific app mappings for better filtering
            app_mappings = {
                'cursor': ['cursor'],
                'whatsapp': ['whatsapp', 'whatsapp desktop', 'whatsapp web'],
                'signal': ['signal', 'signal desktop'],
                'netflix': ['netflix', 'netflix app'],
                'spotify': ['spotify', 'spotify app'],
                'youtube': ['youtube', 'youtube app'],
                'chrome': ['chrome', 'google chrome', 'brave browser'],
                'browser': ['chrome', 'google chrome', 'brave browser', 'safari', 'firefox'],
                'terminal': ['terminal', 'iterm2', 'alacritty'],
                'code': ['cursor', 'vscode', 'visual studio code', 'sublime text'],
                'editor': ['cursor', 'vscode', 'visual studio code', 'sublime text'],
                'file': ['finder', 'explorer', 'cursor', 'vscode'],
                'document': ['cursor', 'vscode', 'microsoft word', 'google docs'],
                'email': ['mail', 'gmail', 'outlook', 'thunderbird'],
                'social': ['facebook', 'instagram', 'twitter', 'whatsapp', 'signal'],
                'communication': ['whatsapp', 'signal', 'telegram', 'discord', 'slack'],
                'video': ['youtube', 'netflix', 'vimeo', 'twitch'],
                'music': ['spotify', 'apple music', 'youtube music'],
                'work': ['cursor', 'vscode', 'slack', 'zoom', 'teams'],
                'meeting': ['zoom', 'teams', 'google meet', 'skype']
            }
            
            # Determine the target app based on query
            target_app = None
            for key, apps in app_mappings.items():
                if key in query_lower:
                    target_app = apps[0]  # Use the primary app name
                    break
            
            # Generate embedding for the query
            embedding = self.generate_embedding(query)
            
            # Call the vector search function with correct parameter order
            result = self.supabase.rpc(
                'match_events_by_embedding',
                {
                    'match_count': limit if limit else 2000,
                    'match_threshold': similarity_threshold,
                    'query_embedding': embedding
                }
            ).execute()
            
            if not result.data:
                logger.info(f"No vector search results found for query: {query}")
                return []
                
            # Filter results based on query context
            filtered_results = []
            for event in result.data:
                data = event.get('data', {})
                app = data.get('app', '').lower()
                title = data.get('title', '').lower()
                
                # If we have a specific target app, filter for it
                if target_app:
                    if target_app.lower() in app:
                        filtered_results.append(event)
                else:
                    # For general queries, use semantic similarity threshold
                    # You can add additional filtering logic here
                    filtered_results.append(event)
            
            # Log the apps found for debugging
            apps_found = sorted(list(set([e.get('data', {}).get('app', '') for e in filtered_results])))
            logger.info(f"Vector search found {len(filtered_results)} filtered results")
            logger.info(f"Apps found in vector search: {apps_found}")
            
            return filtered_results
            
        except Exception as e:
            logger.error(f"Error in vector search: {e}")
            # Fallback to text search
            return self.simple_text_search(query, limit=limit)

    def search_events_text(self, query, field="content", limit=None):
        """Search events using text search with improved app matching"""
        try:
            # For app searches, try exact match first
            if field == "app":
                # Use data->>'app' = 'WhatsApp' for exact match
                data = self.supabase.table('events').select('*').eq('data->>app', query).order('timestamp', desc=True).limit(limit or 2000).execute()
                if data.data:
                    return data.data
                    
                # If exact match fails, try case-insensitive search
                data = self.supabase.table('events').select('*').ilike('data->>app', query).order('timestamp', desc=True).limit(limit or 2000).execute()
                if data.data:
                    return data.data
                    
            # For content searches or if app match fails
            data = self.supabase.table('events').select('*').ilike(f'data->>{field}', f'%{query}%').order('timestamp', desc=True).limit(limit or 2000).execute()
            return data.data if data.data else []
            
        except Exception as e:
            logger.error(f"Text search error: {e}")
            return [] 